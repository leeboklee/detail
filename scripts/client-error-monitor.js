#!/usr/bin/env node

const puppeteer = require('puppeteer')
const fs = require('fs')
const path = require('path')

class ClientErrorMonitor {
  constructor() {
    this.browser = null
    this.page = null
    this.logDir = path.join(process.cwd(), 'logs', 'client-errors')
    this.errorCount = 0
    this.fixedErrors = []
  }

  async start() {
    console.log('üëÅÔ∏è ÌÅ¥ÎùºÏù¥Ïñ∏Ìä∏ Ïò§Î•ò Î™®ÎãàÌÑ∞ÎßÅ ÏãúÏûë...')
    
    try {
      // Î°úÍ∑∏ ÎîîÎ†âÌÜ†Î¶¨ ÏÉùÏÑ±
      if (!fs.existsSync(this.logDir)) {
        fs.mkdirSync(this.logDir, { recursive: true })
      }
      
      // Î∏åÎùºÏö∞Ï†Ä ÏãúÏûë
      this.browser = await puppeteer.launch({
        headless: false,
        args: ['--no-sandbox', '--disable-setuid-sandbox', '--disable-dev-shm-usage']
      })
      
      this.page = await this.browser.newPage()
      
      // Ïò§Î•ò Ïù¥Î≤§Ìä∏ Î¶¨Ïä§ÎÑà ÏÑ§Ï†ï
      this.setupErrorListeners()
      
      // ÌéòÏù¥ÏßÄ Ï†ëÏÜç
      await this.page.goto('http://localhost:3900', {
        waitUntil: 'domcontentloaded',
        timeout: 60000
      })
      
      console.log('‚úÖ ÌÅ¥ÎùºÏù¥Ïñ∏Ìä∏ Î™®ÎãàÌÑ∞ÎßÅ ÏãúÏûëÎê®')
      
      // Ïã§ÏãúÍ∞Ñ Î™®ÎãàÌÑ∞ÎßÅ ÏãúÏûë
      await this.startRealTimeMonitoring()
      
    } catch (error) {
      console.error('‚ùå ÌÅ¥ÎùºÏù¥Ïñ∏Ìä∏ Î™®ÎãàÌÑ∞ÎßÅ ÏãúÏûë Ïã§Ìå®:', error)
    }
  }

  setupErrorListeners() {
    // ÏΩòÏÜî Ïò§Î•ò ÏàòÏßë
    this.page.on('console', async (msg) => {
      if (msg.type() === 'error') {
        console.log('üî¥ ÏΩòÏÜî Ïò§Î•ò Í∞êÏßÄ:', msg.text())
        await this.handleConsoleError(msg.text())
      }
    })
    
    // ÌéòÏù¥ÏßÄ Ïò§Î•ò ÏàòÏßë
    this.page.on('pageerror', async (error) => {
      console.log('üî¥ ÌéòÏù¥ÏßÄ Ïò§Î•ò Í∞êÏßÄ:', error.message)
      await this.handlePageError(error)
    })
    
    // ÎÑ§Ìä∏ÏõåÌÅ¨ Ïò§Î•ò ÏàòÏßë
    this.page.on('response', async (response) => {
      if (!response.ok()) {
        console.log('üî¥ ÎÑ§Ìä∏ÏõåÌÅ¨ Ïò§Î•ò Í∞êÏßÄ:', response.status(), response.url())
        await this.handleNetworkError(response)
      }
    })
    
    // ÏöîÏ≤≠ Ïã§Ìå® ÏàòÏßë
    this.page.on('requestfailed', async (request) => {
      console.log('üî¥ ÏöîÏ≤≠ Ïã§Ìå® Í∞êÏßÄ:', request.url())
      await this.handleRequestFailure(request)
    })
  }

  async handleConsoleError(errorText) {
    this.errorCount++
    
    const errorData = {
      type: 'console_error',
      message: errorText,
      timestamp: new Date().toISOString(),
      url: this.page.url(),
      stack: null
    }
    
    // Ïò§Î•ò Ìå®ÌÑ¥ Î∂ÑÏÑù Î∞è ÏûêÎèô ÏàòÏ†ï
    const fixResult = await this.analyzeAndFixError(errorData)
    
    if (fixResult.fixed) {
      this.fixedErrors.push({
        original: errorData,
        fix: fixResult,
        timestamp: new Date().toISOString()
      })
    }
    
    // Ïò§Î•ò Î°úÍ∑∏ Ï†ÄÏû•
    this.saveErrorLog(errorData)
  }

  async handlePageError(error) {
    this.errorCount++
    
    const errorData = {
      type: 'page_error',
      message: error.message,
      timestamp: new Date().toISOString(),
      url: this.page.url(),
      stack: error.stack
    }
    
    // Ïò§Î•ò Ìå®ÌÑ¥ Î∂ÑÏÑù Î∞è ÏûêÎèô ÏàòÏ†ï
    const fixResult = await this.analyzeAndFixError(errorData)
    
    if (fixResult.fixed) {
      this.fixedErrors.push({
        original: errorData,
        fix: fixResult,
        timestamp: new Date().toISOString()
      })
    }
    
    // Ïò§Î•ò Î°úÍ∑∏ Ï†ÄÏû•
    this.saveErrorLog(errorData)
  }

  async handleNetworkError(response) {
    this.errorCount++
    
    const errorData = {
      type: 'network_error',
      message: `HTTP ${response.status()}: ${response.statusText()}`,
      timestamp: new Date().toISOString(),
      url: response.url(),
      status: response.status(),
      headers: response.headers()
    }
    
    // ÎÑ§Ìä∏ÏõåÌÅ¨ Ïò§Î•ò Î∂ÑÏÑù
    const fixResult = await this.analyzeNetworkError(errorData)
    
    if (fixResult.fixed) {
      this.fixedErrors.push({
        original: errorData,
        fix: fixResult,
        timestamp: new Date().toISOString()
      })
    }
    
    // Ïò§Î•ò Î°úÍ∑∏ Ï†ÄÏû•
    this.saveErrorLog(errorData)
  }

  async handleRequestFailure(request) {
    this.errorCount++
    
    const errorData = {
      type: 'request_failure',
      message: `Request failed: ${request.url()}`,
      timestamp: new Date().toISOString(),
      url: request.url(),
      method: request.method(),
      headers: request.headers()
    }
    
    // ÏöîÏ≤≠ Ïã§Ìå® Î∂ÑÏÑù
    const fixResult = await this.analyzeRequestFailure(errorData)
    
    if (fixResult.fixed) {
      this.fixedErrors.push({
        original: errorData,
        fix: fixResult,
        timestamp: new Date().toISOString()
      })
    }
    
    // Ïò§Î•ò Î°úÍ∑∏ Ï†ÄÏû•
    this.saveErrorLog(errorData)
  }

  async analyzeAndFixError(errorData) {
    const errorMessage = errorData.message.toLowerCase()
    
    // ÏùºÎ∞òÏ†ÅÏù∏ Ïò§Î•ò Ìå®ÌÑ¥ Î∂ÑÏÑù
    if (errorMessage.includes('cannot read property')) {
      return await this.fixPropertyAccessError(errorData)
    }
    
    if (errorMessage.includes('is not a function')) {
      return await this.fixFunctionCallError(errorData)
    }
    
    if (errorMessage.includes('unexpected token')) {
      return await this.fixSyntaxError(errorData)
    }
    
    if (errorMessage.includes('module not found')) {
      return await this.fixModuleError(errorData)
    }
    
    return { fixed: false, reason: 'Unknown error pattern' }
  }

  async fixPropertyAccessError(errorData) {
    console.log('üîß ÏÜçÏÑ± Ï†ëÍ∑º Ïò§Î•ò ÏàòÏ†ï ÏãúÎèÑ...')
    
    try {
      // ÏïàÏ†ÑÌïú ÏÜçÏÑ± Ï†ëÍ∑º ÏΩîÎìú ÏÉùÏÑ±
      const safeCode = `
        // ÏïàÏ†ÑÌïú ÏÜçÏÑ± Ï†ëÍ∑º Ìó¨Ìçº Ìï®Ïàò
        function safeGet(obj, path, defaultValue = null) {
          return path.split('.').reduce((current, key) => {
            return current && current[key] !== undefined ? current[key] : defaultValue
          }, obj)
        }
        
        // Í∏∞Ï°¥ ÏΩîÎìúÎ•º ÏïàÏ†ÑÌïú Ï†ëÍ∑ºÏúºÎ°ú Î≥ÄÍ≤Ω
        // Ïòà: obj.property.subProperty -> safeGet(obj, 'property.subProperty')
      `
      
      // ÌéòÏù¥ÏßÄÏóê ÏïàÏ†ÑÌïú Ï†ëÍ∑º ÏΩîÎìú Ï£ºÏûÖ
      await this.page.evaluate(safeCode)
      
      return {
        fixed: true,
        type: 'property_access',
        solution: 'Safe property access helper injected',
        code: safeCode
      }
      
    } catch (error) {
      return { fixed: false, reason: error.message }
    }
  }

  async fixFunctionCallError(errorData) {
    console.log('üîß Ìï®Ïàò Ìò∏Ï∂ú Ïò§Î•ò ÏàòÏ†ï ÏãúÎèÑ...')
    
    try {
      // Ìï®Ïàò Ï°¥Ïû¨ Ïó¨Î∂Ä ÌôïÏù∏ ÏΩîÎìú
      const functionCheckCode = `
        // Ìï®Ïàò Ï°¥Ïû¨ Ïó¨Î∂Ä ÌôïÏù∏ Ìó¨Ìçº
        function safeCall(obj, methodName, ...args) {
          if (obj && typeof obj[methodName] === 'function') {
            return obj[methodName](...args)
          }
          console.warn('Method not found:', methodName)
          return null
        }
      `
      
      await this.page.evaluate(functionCheckCode)
      
      return {
        fixed: true,
        type: 'function_call',
        solution: 'Safe function call helper injected',
        code: functionCheckCode
      }
      
    } catch (error) {
      return { fixed: false, reason: error.message }
    }
  }

  async fixSyntaxError(errorData) {
    console.log('üîß Íµ¨Î¨∏ Ïò§Î•ò ÏàòÏ†ï ÏãúÎèÑ...')
    
    try {
      // Íµ¨Î¨∏ Ïò§Î•ò Î≥µÍµ¨ ÏãúÎèÑ
      await this.page.evaluate(() => {
        // Ï†ÑÏó≠ Ïò§Î•ò Ìï∏Îì§Îü¨ Ï∂îÍ∞Ä
        window.addEventListener('error', (event) => {
          console.warn('Syntax error caught:', event.error)
          event.preventDefault()
        })
      })
      
      return {
        fixed: true,
        type: 'syntax_error',
        solution: 'Global error handler added',
        code: 'Global error handler'
      }
      
    } catch (error) {
      return { fixed: false, reason: error.message }
    }
  }

  async fixModuleError(errorData) {
    console.log('üîß Î™®Îìà Ïò§Î•ò ÏàòÏ†ï ÏãúÎèÑ...')
    
    try {
      // Î™®Îìà Î°úÎìú Ïû¨ÏãúÎèÑ
      await this.page.evaluate(() => {
        // ÎèôÏ†Å Î™®Îìà Î°úÎìú Ìó¨Ìçº
        window.loadModule = async (moduleName) => {
          try {
            return await import(moduleName)
          } catch (error) {
            console.warn('Module load failed:', moduleName, error)
            return null
          }
        }
      })
      
      return {
        fixed: true,
        type: 'module_error',
        solution: 'Dynamic module loader added',
        code: 'Dynamic module loader'
      }
      
    } catch (error) {
      return { fixed: false, reason: error.message }
    }
  }

  async analyzeNetworkError(errorData) {
    // ÎÑ§Ìä∏ÏõåÌÅ¨ Ïò§Î•ò Î∂ÑÏÑù
    if (errorData.status === 404) {
      return {
        fixed: false,
        type: 'not_found',
        solution: 'Resource not found - check URL',
        recommendation: 'Verify the requested resource exists'
      }
    }
    
    if (errorData.status === 500) {
      return {
        fixed: false,
        type: 'server_error',
        solution: 'Server internal error',
        recommendation: 'Check server logs for details'
      }
    }
    
    return { fixed: false, reason: 'Network error analysis completed' }
  }

  async analyzeRequestFailure(errorData) {
    // ÏöîÏ≤≠ Ïã§Ìå® Î∂ÑÏÑù
    return {
      fixed: false,
      type: 'request_failure',
      solution: 'Request failed - check network connectivity',
      recommendation: 'Verify network connection and server status'
    }
  }

  saveErrorLog(errorData) {
    const logFile = path.join(this.logDir, `client-error-${Date.now()}.json`)
    fs.writeFileSync(logFile, JSON.stringify(errorData, null, 2))
  }

  async startRealTimeMonitoring() {
    console.log('üîÑ Ïã§ÏãúÍ∞Ñ Î™®ÎãàÌÑ∞ÎßÅ ÏãúÏûë...')
    
    // Ï£ºÍ∏∞Ï†Å ÏÉÅÌÉú Ï≤¥ÌÅ¨
    setInterval(async () => {
      try {
        // ÌéòÏù¥ÏßÄ ÏÉÅÌÉú ÌôïÏù∏
        const pageState = await this.page.evaluate(() => {
          return {
            readyState: document.readyState,
            errorCount: window.errorCount || 0,
            performance: performance.now()
          }
        })
        
        console.log('üìä ÌéòÏù¥ÏßÄ ÏÉÅÌÉú:', pageState)
        
        // Ïò§Î•ò ÌÜµÍ≥Ñ Ï∂úÎ†•
        if (this.errorCount > 0) {
          console.log(`üìà Ïò§Î•ò ÌÜµÍ≥Ñ: Ï¥ù ${this.errorCount}Í∞ú, ÏàòÏ†ïÎê® ${this.fixedErrors.length}Í∞ú`)
        }
        
      } catch (error) {
        console.error('‚ùå ÏÉÅÌÉú Ï≤¥ÌÅ¨ Ïã§Ìå®:', error)
      }
    }, 30000) // 30Ï¥àÎßàÎã§ Ï≤¥ÌÅ¨
  }

  async stop() {
    if (this.browser) {
      await this.browser.close()
      console.log('üõë ÌÅ¥ÎùºÏù¥Ïñ∏Ìä∏ Î™®ÎãàÌÑ∞ÎßÅ Ï¢ÖÎ£åÎê®')
    }
  }
}

// CLI Ïã§Ìñâ
async function main() {
  const monitor = new ClientErrorMonitor()
  
  try {
    await monitor.start()
    
    // Î¨¥Ìïú ÎåÄÍ∏∞ (Ctrl+CÎ°ú Ï¢ÖÎ£å)
    process.on('SIGINT', async () => {
      console.log('\nüõë Î™®ÎãàÌÑ∞ÎßÅ Ï¢ÖÎ£å Ï§ë...')
      await monitor.stop()
      process.exit(0)
    })
    
  } catch (error) {
    console.error('‚ùå Î™®ÎãàÌÑ∞ÎßÅ Ïã§Ìå®:', error)
    await monitor.stop()
  }
}

if (require.main === module) {
  main()
}

module.exports = ClientErrorMonitor 