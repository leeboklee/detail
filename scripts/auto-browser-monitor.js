const puppeteer = require('puppeteer');
const WebSocket = require('ws');
const http = require('http');
const fs = require('fs');
const path = require('path');

class AutoBrowserMonitor {
  constructor() {
    this.browser = null;
    this.page = null;
    this.wss = null;
    this.server = null;
    this.errorLog = [];
    this.autoFixEnabled = true;
    this.projectRoot = process.cwd();
  }

  async start() {
    console.log('üöÄ ÏûêÎèô Î∏åÎùºÏö∞Ï†Ä Ïò§Î•ò Î™®ÎãàÌÑ∞ÎßÅ ÏãúÏûë...');
    
    try {
      // WebSocket ÏÑúÎ≤Ñ ÏãúÏûë
      await this.startWebSocketServer();
      
      // Î∏åÎùºÏö∞Ï†Ä ÏãúÏûë
      await this.startBrowser();
      
      // ÌéòÏù¥ÏßÄ Î°úÎìú Î∞è Î™®ÎãàÌÑ∞ÎßÅ ÏΩîÎìú Ï£ºÏûÖ
      await this.loadPageAndInject();
      
      console.log('‚úÖ ÏûêÎèô Î™®ÎãàÌÑ∞ÎßÅ ÏôÑÏ†Ñ ÌôúÏÑ±ÌôîÎê®');
      console.log('üéØ Ïù¥Ï†ú Î∏åÎùºÏö∞Ï†ÄÏóêÏÑú Î∞úÏÉùÌïòÎäî Î™®Îì† Ïò§Î•òÍ∞Ä ÏûêÎèôÏúºÎ°ú Í∞êÏßÄÎêòÍ≥† ÏàòÏ†ïÎê©ÎãàÎã§!');
      
    } catch (error) {
      console.error('‚ùå ÏûêÎèô Î™®ÎãàÌÑ∞ÎßÅ ÏãúÏûë Ïã§Ìå®:', error.message);
    }
  }

  async startWebSocketServer() {
    this.server = http.createServer();
    this.wss = new WebSocket.Server({ server: this.server });

    this.wss.on('connection', (ws) => {
      console.log('‚úÖ Î∏åÎùºÏö∞Ï†Ä ÏûêÎèô Ïó∞Í≤∞Îê®');
      
      ws.on('message', (data) => {
        try {
          const message = JSON.parse(data);
          this.handleBrowserMessage(message);
        } catch (error) {
          console.error('‚ùå Î©îÏãúÏßÄ ÌååÏã± Ïò§Î•ò:', error.message);
        }
      });

      ws.on('close', () => {
        console.log('‚ùå Î∏åÎùºÏö∞Ï†Ä Ïó∞Í≤∞ Ìï¥Ï†ú');
      });
    });

    const PORT = 3901;
    return new Promise((resolve) => {
      this.server.listen(PORT, () => {
        console.log(`‚úÖ WebSocket ÏÑúÎ≤Ñ ÏãúÏûë: ws://localhost:${PORT}`);
        resolve();
      });
    });
  }

  async startBrowser() {
    this.browser = await puppeteer.launch({
      headless: false,
      defaultViewport: { width: 1920, height: 1080 },
      args: ['--no-sandbox', '--disable-setuid-sandbox']
    });

    this.page = await this.browser.newPage();
    
    // Î∏åÎùºÏö∞Ï†Ä ÏΩòÏÜî Î°úÍ∑∏ ÏàòÏßë
    this.page.on('console', (msg) => {
      this.handleConsoleMessage(msg);
    });

    // ÌéòÏù¥ÏßÄ Ïò§Î•ò ÏàòÏßë
    this.page.on('pageerror', (error) => {
      this.handlePageError(error);
    });
  }

  async loadPageAndInject() {
    // ÌéòÏù¥ÏßÄ Î°úÎìú
    await this.page.goto('http://localhost:3900', { 
      waitUntil: 'networkidle0',
      timeout: 30000 
    });

    console.log('‚úÖ ÌéòÏù¥ÏßÄ Î°úÎìú ÏôÑÎ£å');

    // Î™®ÎãàÌÑ∞ÎßÅ ÏΩîÎìú ÏûêÎèô Ï£ºÏûÖ
    await this.page.evaluate(() => {
      // Ïù¥ÎØ∏ Ï£ºÏûÖÎêú Í≤ΩÏö∞ Ï§ëÎ≥µ Î∞©ÏßÄ
      if (window.monitoringActive) return;
      window.monitoringActive = true;

      console.log('üîó ÏûêÎèô Î™®ÎãàÌÑ∞ÎßÅ ÏΩîÎìú Ï£ºÏûÖ Ï§ë...');
      
      const ws = new WebSocket('ws://localhost:3901');
      
      // Ïó∞Í≤∞ ÏÉÅÌÉú ÌëúÏãú
      ws.onopen = () => {
        console.log('‚úÖ ÏûêÎèô Î™®ÎãàÌÑ∞ÎßÅ Ïó∞Í≤∞Îê®');
        document.body.style.border = '3px solid #10B981';
        document.body.style.borderRadius = '8px';
      };
      
      ws.onclose = () => {
        console.log('‚ùå ÏûêÎèô Î™®ÎãàÌÑ∞ÎßÅ Ïó∞Í≤∞ Ìï¥Ï†ú');
        document.body.style.border = '3px solid #EF4444';
      };
      
      ws.onerror = (error) => {
        console.error('‚ùå WebSocket Ïò§Î•ò:', error);
        document.body.style.border = '3px solid #F59E0B';
      };
      
      // ÏΩòÏÜî Ïò§Î•ò ÏàòÏßë Í∞ïÌôî
      const originalError = console.error;
      const originalWarn = console.warn;
      const originalLog = console.log;
      
      console.error = function(...args) {
        const message = args.join(' ');
        console.log('üö® ÏΩòÏÜî Ïò§Î•ò Í∞êÏßÄ:', message);
        
        // Hydration Ïò§Î•ò ÌäπÎ≥Ñ Í∞êÏßÄ
        if (message.includes('Text content does not match server-rendered HTML') ||
            message.includes('Server:') && message.includes('Client:')) {
          console.log('üö® Hydration Ïò§Î•ò ÌäπÎ≥Ñ Í∞êÏßÄÎê®!');
          if (ws.readyState === WebSocket.OPEN) {
            ws.send(JSON.stringify({
              type: 'hydration-error',
              message: message,
              timestamp: new Date().toISOString(),
              stack: new Error().stack,
              priority: 'high'
            }));
          }
        }
        
        if (ws.readyState === WebSocket.OPEN) {
          ws.send(JSON.stringify({
            type: 'console-error',
            message: message,
            timestamp: new Date().toISOString(),
            stack: new Error().stack
          }));
        }
        originalError.apply(console, args);
      };
      
      console.warn = function(...args) {
        const message = args.join(' ');
        console.log('‚ö†Ô∏è ÏΩòÏÜî Í≤ΩÍ≥† Í∞êÏßÄ:', message);
        if (ws.readyState === WebSocket.OPEN) {
          ws.send(JSON.stringify({
            type: 'console-warn',
            message: message,
            timestamp: new Date().toISOString()
          }));
        }
        originalWarn.apply(console, args);
      };

      // Î™®Îì† ÏΩòÏÜî Î°úÍ∑∏ ÏàòÏßë (ÎîîÎ≤ÑÍπÖÏö©)
      console.log = function(...args) {
        const message = args.join(' ');
        if (message.includes('Text content does not match') || 
            message.includes('Server:') || 
            message.includes('Client:') ||
            message.includes('hydration')) {
          console.log('üö® Ï§ëÏöî Î°úÍ∑∏ Í∞êÏßÄ:', message);
          if (ws.readyState === WebSocket.OPEN) {
            ws.send(JSON.stringify({
              type: 'important-log',
              message: message,
              timestamp: new Date().toISOString()
            }));
          }
        }
        originalLog.apply(console, args);
      };
      
      // ÌéòÏù¥ÏßÄ Ïò§Î•ò ÏàòÏßë
      window.addEventListener('error', (event) => {
        console.log('üö® ÌéòÏù¥ÏßÄ Ïò§Î•ò Í∞êÏßÄ:', event.message);
        if (ws.readyState === WebSocket.OPEN) {
          ws.send(JSON.stringify({
            type: 'page-error',
            message: event.message,
            filename: event.filename,
            lineno: event.lineno,
            colno: event.colno,
            stack: event.error?.stack,
            timestamp: new Date().toISOString()
          }));
        }
      });
      
      // React Ïò§Î•ò ÏàòÏßë
      window.addEventListener('unhandledrejection', (event) => {
        console.log('üö® React Ïò§Î•ò Í∞êÏßÄ:', event.reason?.message || event.reason);
        if (ws.readyState === WebSocket.OPEN) {
          ws.send(JSON.stringify({
            type: 'unhandled-rejection',
            message: event.reason?.message || event.reason,
            stack: event.reason?.stack,
            timestamp: new Date().toISOString()
          }));
        }
      });

      // Next.js Ïò§Î•ò ÏàòÏßë Í∞ïÌôî
      window.addEventListener('error', (event) => {
        const errorMessage = event.message || '';
        if (errorMessage.includes('Text content does not match server-rendered HTML') || 
            errorMessage.includes('hydration') ||
            (errorMessage.includes('Server:') && errorMessage.includes('Client:'))) {
          console.log('üö® Hydration Ïò§Î•ò Í∞êÏßÄ:', errorMessage);
          if (ws.readyState === WebSocket.OPEN) {
            ws.send(JSON.stringify({
              type: 'hydration-error',
              message: errorMessage,
              filename: event.filename,
              lineno: event.lineno,
              colno: event.colno,
              stack: event.error?.stack,
              timestamp: new Date().toISOString(),
              priority: 'high'
            }));
          }
        }
      });

      // DOM Î≥ÄÍ≤Ω Í∞êÏßÄÎ°ú Hydration Ïò§Î•ò Ìè¨Ï∞© Í∞ïÌôî
      const observer = new MutationObserver((mutations) => {
        mutations.forEach((mutation) => {
          if (mutation.type === 'childList') {
            mutation.addedNodes.forEach((node) => {
              if (node.nodeType === Node.ELEMENT_NODE) {
                // Hydration Ïò§Î•ò Í¥ÄÎ†® ÏöîÏÜå Í∞êÏßÄ
                const textContent = node.textContent || '';
                if (textContent.includes('Server:') && textContent.includes('Client:')) {
                  console.log('üö® Hydration Ïò§Î•ò ÏöîÏÜå Í∞êÏßÄ:', textContent);
                  if (ws.readyState === WebSocket.OPEN) {
                    ws.send(JSON.stringify({
                      type: 'hydration-error',
                      message: 'Hydration mismatch detected in DOM',
                      element: textContent,
                      timestamp: new Date().toISOString(),
                      priority: 'high'
                    }));
                  }
                }
              }
            });
          }
        });
      });
      
      observer.observe(document.body, {
        childList: true,
        subtree: true,
        attributes: true
      });

      // Ï£ºÍ∏∞Ï†Å Hydration ÏÉÅÌÉú Ï≤¥ÌÅ¨
      setInterval(() => {
        // ÌéòÏù¥ÏßÄÏóêÏÑú Hydration Ïò§Î•ò ÏöîÏÜå Ï∞æÍ∏∞
        const errorElements = document.querySelectorAll('*');
        errorElements.forEach(element => {
          const text = element.textContent || '';
          if (text.includes('Server:') && text.includes('Client:')) {
            console.log('üö® Ï£ºÍ∏∞Ï†Å Hydration Ïò§Î•ò Í∞êÏßÄ:', text);
            if (ws.readyState === WebSocket.OPEN) {
              ws.send(JSON.stringify({
                type: 'hydration-error',
                message: 'Periodic hydration error check',
                element: text,
                timestamp: new Date().toISOString(),
                priority: 'high'
              }));
            }
          }
        });
      }, 3000);
      
      // Ï£ºÍ∏∞Ï†Å ÏÉÅÌÉú Î≥¥Í≥†
      setInterval(() => {
        if (ws.readyState === WebSocket.OPEN) {
          const state = {
            type: 'status',
            url: window.location.href,
            title: document.title,
            hasErrors: document.querySelectorAll('.error, [data-error]').length > 0,
            hydrationComplete: document.body.classList.contains('hydration-complete'),
            timestamp: new Date().toISOString()
          };
          ws.send(JSON.stringify(state));
        }
      }, 5000);
      
      // ÏàòÏ†ï Î™ÖÎ†π ÏàòÏã†
      ws.addEventListener('message', (event) => {
        try {
          const command = JSON.parse(event.data);
          if (command.type === 'fix-command') {
            console.log('üîß ÏàòÏ†ï Î™ÖÎ†π ÏàòÏã†:', command.action);
            executeFixCommand(command);
          }
        } catch (error) {
          console.error('‚ùå Î™ÖÎ†π ÌååÏã± Ïò§Î•ò:', error);
        }
      });
      
      function executeFixCommand(command) {
        switch (command.action) {
          case 'reload':
            console.log('üîÑ ÌéòÏù¥ÏßÄ ÏÉàÎ°úÍ≥†Ïπ® Ïã§Ìñâ');
            window.location.reload();
            break;
          case 'clear-storage':
            console.log('üßπ Ïä§ÌÜ†Î¶¨ÏßÄ ÌÅ¥Î¶¨Ïñ¥ Ïã§Ìñâ');
            localStorage.clear();
            sessionStorage.clear();
            window.location.reload();
            break;
          case 'wait-hydration':
            console.log('‚è≥ Hydration ÎåÄÍ∏∞');
            const checkHydration = setInterval(() => {
              if (document.body.classList.contains('hydration-complete')) {
                clearInterval(checkHydration);
                console.log('‚úÖ Hydration ÏôÑÎ£å');
              }
            }, 100);
            break;
          case 'fix-hydration':
            console.log('üîß Hydration Ïò§Î•ò ÏàòÏ†ï ÏãúÎèÑ');
            setTimeout(() => {
              console.log('üîÑ Hydration Ïò§Î•òÎ°ú Ïù∏Ìïú ÌéòÏù¥ÏßÄ ÏÉàÎ°úÍ≥†Ïπ®');
              window.location.reload();
            }, 1000);
            break;
          case 'retry-request':
            console.log('üîÑ ÎÑ§Ìä∏ÏõåÌÅ¨ ÏöîÏ≤≠ Ïû¨ÏãúÎèÑ');
            break;
        }
      }
      
      console.log('üéØ ÏûêÎèô Ïò§Î•ò Î™®ÎãàÌÑ∞ÎßÅ ÌôúÏÑ±ÌôîÎê®');
    });

    // ÌÖåÏä§Ìä∏ Î©îÏãúÏßÄ Ï†ÑÏÜ°
    setTimeout(async () => {
      await this.page.evaluate(() => {
        if (window.WebSocket && window.WebSocket.OPEN) {
          console.log('üß™ ÏûêÎèô Ïó∞Í≤∞ ÌÖåÏä§Ìä∏ ÏôÑÎ£å');
        }
      });
    }, 2000);
  }

  handleConsoleMessage(msg) {
    const message = {
      type: msg.type(),
      text: msg.text(),
      timestamp: new Date().toISOString()
    };

    if (message.type === 'error') {
      console.log(`[${message.type.toUpperCase()}] ${message.text}`);
      this.errorLog.push({
        type: 'console-error',
        message: message.text,
        timestamp: message.timestamp
      });
    }
  }

  handlePageError(error) {
    const errorInfo = {
      type: 'page-error',
      message: error.message,
      stack: error.stack,
      timestamp: new Date().toISOString()
    };

    console.error('‚ùå ÌéòÏù¥ÏßÄ Ïò§Î•ò:', errorInfo.message);
    this.errorLog.push(errorInfo);
  }

  handleBrowserMessage(message) {
    console.log(`[${message.type.toUpperCase()}] ${message.message || message.url || 'ÏÉÅÌÉú ÏóÖÎç∞Ïù¥Ìä∏'}`);
    
    if (message.type !== 'status') {
      this.errorLog.push(message);
      
      if (this.autoFixEnabled) {
        this.autoFixError(message);
      }
    }
    
    if (message.type === 'status' && message.hasErrors) {
      console.log('‚ö†Ô∏è ÌéòÏù¥ÏßÄÏóê Ïò§Î•ò ÏöîÏÜå Î∞úÍ≤¨');
    }
  }

  autoFixError(error) {
    console.log('üîß ÏûêÎèô ÏàòÏ†ï ÏãúÎèÑ:', error.message?.substring(0, 50) || error.type);
    
    // Î∏åÎùºÏö∞Ï†ÄÏóê ÏàòÏ†ï Î™ÖÎ†π Ï†ÑÏÜ°
    this.page.evaluate((errorData) => {
      if (window.ws && window.ws.readyState === WebSocket.OPEN) {
        const fixCommand = {
          type: 'fix-command',
          action: 'reload',
          target: 'page',
          reason: 'ÏûêÎèô Ïò§Î•ò ÏàòÏ†ï'
        };
        
        if (errorData.message?.includes('Text content does not match server-rendered HTML') || 
            errorData.message?.includes('hydration') ||
            errorData.type === 'hydration-error') {
          fixCommand.action = 'fix-hydration';
          fixCommand.reason = 'Hydration Ïò§Î•ò ÏûêÎèô ÏàòÏ†ï';
        } else if (errorData.type === 'page-error') {
          fixCommand.action = 'clear-storage';
        }
        
        window.ws.send(JSON.stringify(fixCommand));
      }
    }, error);
  }

  async stop() {
    console.log('üõë ÏûêÎèô Î™®ÎãàÌÑ∞ÎßÅ Ï§ëÏßÄ...');
    
    if (this.browser) {
      await this.browser.close();
    }
    
    if (this.wss) {
      this.wss.close();
    }
    
    if (this.server) {
      this.server.close();
    }
    
    this.saveErrorLog();
  }

  saveErrorLog() {
    const logPath = path.join(this.projectRoot, 'logs', 'auto-browser-errors.json');
    const logDir = path.dirname(logPath);
    
    if (!fs.existsSync(logDir)) {
      fs.mkdirSync(logDir, { recursive: true });
    }

    const logData = {
      timestamp: new Date().toISOString(),
      totalErrors: this.errorLog.length,
      errors: this.errorLog
    };

    fs.writeFileSync(logPath, JSON.stringify(logData, null, 2));
    console.log(`üìù Ïò§Î•ò Î°úÍ∑∏ Ï†ÄÏû•: ${logPath}`);
  }
}

// CLI Ïã§Ìñâ
if (require.main === module) {
  const monitor = new AutoBrowserMonitor();
  
  process.on('SIGINT', async () => {
    console.log('\nüõë Ï¢ÖÎ£å Ïã†Ìò∏ ÏàòÏã†...');
    await monitor.stop();
    process.exit(0);
  });

  process.on('SIGTERM', async () => {
    console.log('\nüõë Ï¢ÖÎ£å Ïã†Ìò∏ ÏàòÏã†...');
    await monitor.stop();
    process.exit(0);
  });

  monitor.start().catch(console.error);
}

module.exports = AutoBrowserMonitor;
